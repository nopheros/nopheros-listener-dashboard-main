<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Listener Dashboard</title>
  <style>
    /* ---- Tower 3 mini player ---- */

.player-wrapper {
  display: flex;
  justify-content: center;
  margin: 24px 16px;
}
.now-playing {
    margin-top: 8px;
    font-size: 14px;
    color: #aaa;
    font-style: italic;
}

.tower3-player-card {
  display: flex;
  align-items: center;
  gap: 16px;
  background: #121212;
  border-radius: 18px;
  padding: 14px 20px;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
  max-width: 520px;
  width: 100%;
}

.tower3-player-logo {
  width: 72px;
  height: 72px;
  border-radius: 12px;
  object-fit: cover;
}

.tower3-player-content h2 {
  margin: 0 0 4px;
  font-size: 1.05rem;
}

.tower3-player-content p {
  margin: 0 0 10px;
  font-size: 0.9rem;
  color: #b0b0b0;
}

.tower3-player-controls {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 4px;
}

.tower3-play-button {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  width: 46px;
  height: 46px;
  border-radius: 50%;
  border: none;
  background: radial-gradient(circle at 30% 30%, #ffffff, #27ae60);
  color: #000;
  font-size: 1.2rem;
  text-decoration: none;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
  transition: transform 0.1s ease, box-shadow 0.1s ease;
}

.tower3-play-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 14px rgba(0, 0, 0, 0.7);
}

.tower3-volume-bar {
  position: relative;
  width: 180px;
  height: 6px;
  border-radius: 999px;
  background: #2b2b2b;
  overflow: hidden;
}

.tower3-volume-fill {
  width: 65%;
  height: 100%;
  background: linear-gradient(90deg, #27ae60, #2ecc71);
}

.tower3-player-content small {
  font-size: 0.75rem;
  color: #888;
}

    body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  margin: 0;
  background:#0b0b0d;
  color:#e9e9ee;
}
header {
  padding: 16px 20px;
  border-bottom: 1px solid #222;
  display:flex;
  gap:12px;
  align-items:center;
}
.badge {
  padding:6px 10px;
  border:1px solid #333;
  border-radius:20px;
  font-size:12px;
  background:#121217;
}
main {
  padding: 24px;
  max-width: 1100px;
  margin: 0 auto;
}
h1 {
  font-size: 22px;
  margin: 0 0 6px 0;
}
.controls {
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
}
/* Small stat box shown above the chart */
.stats {
  margin-top:12px;
  display:flex;
  gap:12px;
  align-items:center;
}
.stat-box {
  background:#121217;
  border:1px solid #222;
  padding:10px 14px;
  border-radius:10px;
  font-size:16px;
}
.stat-box strong { font-weight:700; color:#e9e9ee; }
/* Hover-reveal Pi health panel */
.health-hover { position: relative; display: inline-block; }
.health-panel {
  position: absolute;
  top: 120%;
  left: 0;
  background: #121217;
  border: 1px solid #333;
  border-radius: 12px;
  padding: 12px;
  min-width: 260px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.5);
  opacity: 0;
  pointer-events: none;
  transform: translateY(-4px);
  transition: opacity .15s ease, transform .15s ease;
  z-index: 10;
}
.health-hover:hover .health-panel { opacity: 1; pointer-events: auto; transform: translateY(0); }
.health-title { font-weight: 600; color: #e9e9ee; margin-bottom: 6px; }
.health-row { display: flex; justify-content: space-between; margin: 6px 0; font-size: 13px; color: #ccc; }
button {
  border:1px solid #333;
  background:#121217;
  color:#e9e9ee;
  padding:8px 12px;
  border-radius:10px;
  cursor:pointer;
}
button.active {
  outline:2px solid #5da;
}
#updated {
  opacity:0.8;
  font-size:12px;
}

/* Chart area */
.chart-wrapper {
  position: relative;
  height: 420px;      /* fixed visual height */
  max-width: 100%;
  margin-top: 12px;
  background:#0e0e12;
  border:1px solid #222;
  border-radius:14px;
  padding:10px;
  box-sizing: border-box;
}

canvas {
  display:block;
  width: 100% !important;
  height: 100% !important;
}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>
<body>
    <!-- Tower 3 - Mini Player Card -->
  
  <header>
    <h1>Listener Dashboard</h1>
    <span class="badge">Live (auto-refresh)</span>
    <span id="updated" class="badge">—</span>
  </header>
  <main>
    <div class="controls">
      <button data-range="24h" class="active">Last 24h</button>
      <button data-range="all">All Time</button>
      <select id="archive-select" class="badge" style="padding:6px 10px;">
        <option value="">Archives…</option>
      </select>
      <button id="refresh">Refresh Now</button>
      <button id="export-csv">Export Current CSV</button>
      <button id="download-json">Download Current JSON</button>
      <div class="health-hover" style="margin-left:8px;">
        <span class="badge">Pi Health ⓘ</span>
        <div class="health-panel">
          <div class="health-title">Raspberry Pi Status</div>
          <div class="health-row"><span>Temperature</span><span id="pi-temp">—</span></div>
          <div class="health-row"><span>Disk</span><span id="pi-disk">—</span></div>
          <div class="health-row"><span>Memory</span><span id="pi-mem">—</span></div>
          <div class="health-row"><span>Load (1/5/15)</span><span id="pi-load">—</span></div>
          <div class="health-row"><span>Updated</span><span id="pi-health-updated">—</span></div>
        </div>
      </div>
    </div>
    <div class="stats">
      <div id="total-box" class="stat-box">Total listeners: <strong id="total-value">—</strong></div>
      <div id="pi-health" class="stat-box">Pi: <strong id="pi-summary">—</strong></div>
    </div>
    <p>Total listeners is the bold line. Click series names in the legend to toggle visibility.</p>
    <div class="chart-wrapper">
      <canvas id="chart"></canvas>
    </div>
    <section class="player-wrapper">
    <div class="tower3-player-card">
      <img
        src="img/logo.jpg"
        alt="Nopheros Logo"
        class="tower3-player-logo"
      />

      <div class="tower3-player-content">
        <h2>Tower 3 – Atlantean Testing Relay</h2>
        <p>That rickety old tower those skeezy Gnomes wouldn't even touch...</p>

        <div class="tower3-player-controls">
          <!-- This acts like the play button: opens the stream URL -->
          <a
            href="http://***REMOVED***:8000/tower3"
            target="_blank"
            rel="noopener noreferrer"
            class="tower3-play-button"
          >
            ▶
          </a>
    <!-- ⭐ NEW: Live Now Playing text -->
    <p id="now-playing" class="now-playing">Loading track…</p>
          <!-- Fake volume bar for the “mini player” look -->
          <div class="tower3-volume-bar">
            <div class="tower3-volume-fill"></div>
          </div>
        </div>

        <small>opens in your browser or media player</small>
      </div>
    </div>
  </section>

  </main>

  <script>
    const paths = {
      "24h": "data/data_24h.json",
      "all": "data/data_all.json"
    };
    let currentRange = "24h";
    let chart;

    async function fetchData(kind) {
      const url = paths[kind];
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load " + url);
      return await res.json();
    }

    async function fetchJSON(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load " + url);
      return await res.json();
    }

    function toDataset(series, isTotal=false) {
      return {
        label: series.name,
        data: series.points.map(([x, y]) => ({ x, y })),
        borderWidth: isTotal ? 3 : 2,
        pointRadius: 0,
        tension: 0.2
      };
    }

    function buildChart(payload) {
      const ctx = document.getElementById('chart').getContext('2d');
      const total = payload.series.find(s => s.name.toLowerCase() === "total");
      const others = payload.series.filter(s => s !== total);

      const datasets = [];
      if (others) datasets.push(...others.map(s => toDataset(s)));
      if (total) datasets.push(toDataset(total, true));

      const config = {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          scales: {
            x: {
              type: 'time',
              time: { unit: 'hour' },
              ticks: { color: '#aaa' },
              grid: { color: '#222' }
            },
            y: {
              beginAtZero: true,
              ticks: { color: '#aaa' },
              grid: { color: '#222' }
            }
          },
          plugins: {
            legend: { labels: { color: '#ddd' } },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                title: (items) => new Date(items[0].parsed.x).toLocaleString()
              }
            }
          },
          interaction: { mode: 'nearest', axis: 'x', intersect: false }
        }
      };
      if (chart) chart.destroy();
      chart = new Chart(ctx, config);
      // Update the small total-listeners box (latest data point of the "Total" series)
      try {
        const totalBoxEl = document.getElementById('total-value');
        if (total && total.points && total.points.length && totalBoxEl) {
          const last = total.points[total.points.length - 1];
          // last is [timestamp, value]
          totalBoxEl.textContent = String(last[1]);
        } else if (totalBoxEl) {
          totalBoxEl.textContent = '—';
        }
      } catch (e) {
        console.warn('Failed updating total box', e);
      }

      document.getElementById('updated').textContent = "Updated: " + (payload.generated_at || new Date().toISOString());
    }

    async function loadRange(kind) {
      try {
        const payload = await fetchData(kind);
        buildChart(payload);
      } catch (e) {
        console.error(e);
        alert("Failed to load data. Have you run the scraper yet?");
      }
    }

    // Hook up controls
    document.querySelectorAll("button[data-range]").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll("button[data-range]").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentRange = btn.dataset.range;
        loadRange(currentRange);
      });
    });
    document.getElementById("refresh").addEventListener("click", () => loadRange(currentRange));

    // Export current range as CSV
    document.getElementById("export-csv").addEventListener("click", async () => {
      try {
        const payload = await fetchData(currentRange);
        // Build a timestamp-indexed map
        const tsSet = new Set();
        const seriesNames = payload.series.map(s => s.name);
        const seriesMap = {};
        payload.series.forEach(s => {
          seriesMap[s.name] = s.points;
          s.points.forEach(([x, _]) => tsSet.add(x));
        });
        const timestamps = Array.from(tsSet).sort((a,b)=>a-b);
        const rows = [];
        // Header
        rows.push(["timestamp_ms", ...seriesNames]);
        const lookup = {};
        for (const name of seriesNames) {
          lookup[name] = new Map(seriesMap[name]);
        }
        for (const ts of timestamps) {
          const row = [ts];
          for (const name of seriesNames) {
            row.push(lookup[name].get(ts) ?? "");
          }
          rows.push(row);
        }
        const csv = rows.map(r => r.join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `listeners_${currentRange}.csv`;
        a.click();
        URL.revokeObjectURL(a.href);
      } catch (e) {
        alert("Failed to export CSV: " + e.message);
      }
    });

    // Download current JSON
    document.getElementById("download-json").addEventListener("click", async () => {
      try {
        const payload = await fetchData(currentRange);
        const blob = new Blob([JSON.stringify(payload)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `listeners_${currentRange}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
      } catch (e) {
        alert("Failed to download JSON: " + e.message);
      }
    });

    // Auto-refresh every 60 seconds
    setInterval(() => loadRange(currentRange), 60000);

    // Initial load
    loadRange(currentRange);
  </script><script>
  // ====== Pi Health Display ======
  async function updatePiHealth() {
    try {
      const data = await fetchJSON("data/pi_health.json");
      const el = document.getElementById("pi-summary");
      if (!el) return;
      const parts = [];
      if (data.temp_c != null) parts.push(`${data.temp_c}°C`);
      if (data.disk_free_gb != null && data.disk_total_gb != null) parts.push(`${data.disk_free_gb}GB free / ${data.disk_total_gb}GB`);
      if (data.mem_available_mb != null && data.mem_total_mb != null) parts.push(`${data.mem_available_mb}MB free / ${data.mem_total_mb}MB`);
      el.textContent = parts.length ? parts.join(" • ") : "—";

      // Fill hover panel details
      const set = (id, text) => { const n = document.getElementById(id); if (n) n.textContent = text; };
      set("pi-temp", data.temp_c != null ? `${data.temp_c}°C` : "—");
      set("pi-disk", (data.disk_free_gb != null && data.disk_total_gb != null) ? `${data.disk_free_gb}GB free / ${data.disk_total_gb}GB` : "—");
      set("pi-mem", (data.mem_available_mb != null && data.mem_total_mb != null) ? `${data.mem_available_mb}MB free / ${data.mem_total_mb}MB` : "—");
      const l = data.loadavg || {};
      set("pi-load", (l["1"] != null && l["5"] != null && l["15"] != null) ? `${l["1"]} / ${l["5"]} / ${l["15"]}` : "—");
      set("pi-health-updated", data.timestamp_iso || "—");
    } catch (e) {
      const el = document.getElementById("pi-summary");
      if (el) el.textContent = "—";
      ["pi-temp","pi-disk","pi-mem","pi-load","pi-health-updated"].forEach(id => {
        const n = document.getElementById(id); if (n) n.textContent = "—";
      });
    }
  }
  updatePiHealth();
  setInterval(updatePiHealth, 60000);

  // ====== Populate Archive Selector (monthly/yearly) ======
  async function populateArchives() {
    try {
      const select = document.getElementById("archive-select");
      const months = await fetchJSON("data/monthly_index.json");
      const years = await fetchJSON("data/yearly_index.json");
      // Clear existing options except placeholder
      [...select.options].slice(1).forEach(o => o.remove());
      // Years
      if (years && Array.isArray(years.years)) {
        years.years.forEach(y => {
          const opt = document.createElement("option");
          opt.value = `year:${y}`;
          opt.textContent = `Year ${y}`;
          select.appendChild(opt);
        });
      }
      // Months
      if (months && Array.isArray(months.months)) {
        months.months.forEach(m => {
          const opt = document.createElement("option");
          opt.value = `month:${m}`;
          opt.textContent = `Month ${m}`;
          select.appendChild(opt);
        });
      }
      // Handle selection
      select.addEventListener("change", async () => {
        const v = select.value;
        if (!v) return;
        try {
          let url = null;
          if (v.startsWith("year:")) {
            const y = v.split(":")[1];
            url = `data/yearly/${y}.json`;
          } else if (v.startsWith("month:")) {
            const m = v.split(":")[1];
            url = `data/monthly/${m}.json`;
          }
          if (url) {
            const payload = await fetchJSON(url);
            buildChart(payload);
            document.getElementById('updated').textContent = "Updated: " + (payload.generated_at || new Date().toISOString());
          }
        } catch (e) {
          alert("Failed to load archive: " + e.message);
        }
      });
    } catch (e) {
      // silently ignore if archives don't exist yet
    }
  }
  populateArchives();
  </script><script>
// ========== NOW PLAYING FETCH LOOP ==========

// URL to your Icecast server’s JSON status output
const NOW_PLAYING_URL = "http://***REMOVED***:8000/status-json.xsl";

// Where we will place the text
const nowPlayingElement = document.getElementById("now-playing");

async function updateNowPlaying() {
    try {
        const response = await fetch(NOW_PLAYING_URL, { cache: "no-store" });
        const data = await response.json();

        // Icecast puts sources inside "icestats.source"
        let source = data.icestats.source;

        // If multiple mountpoints exist, pick /tower3 only
        if (Array.isArray(source)) {
            source = source.find(s => s.listenurl && s.listenurl.includes("/tower3"));
        }

        if (source && source.title) {
            nowPlayingElement.textContent = "Now Playing: " + source.title;
        } else {
            nowPlayingElement.textContent = "Now Playing: (no metadata)";
        }
    } catch (err) {
        nowPlayingElement.textContent = "Now Playing: (unavailable)";
        console.error("Metadata fetch failed:", err);
    }
}

// Run immediately
updateNowPlaying();

// Refresh every 10 seconds
setInterval(updateNowPlaying, 10000);
</script>

  <!-- Lightweight time adapter using Chart.js built-in date functionality via Intl, no extra deps -->
</body>
</html>
